import requests
import shutil
import sys
import os
import fcntl
import time
import hashlib
from configurations.params import NEXUS_DIR, NEXUS_USERNAME
from configurations.global_data import get_global_data

def acquire_lock(lock_file_path, timeout=300):
    """
    Acquire a file lock with timeout.
    
    Args:
        lock_file_path: Path to the lock file
        timeout: Maximum time to wait for lock in seconds
    
    Returns:
        File handle if lock acquired, None if timeout
    """
    start_time = time.time()
    lock_file = None
    
    while time.time() - start_time < timeout:
        try:
            # Create lock file if it doesn't exist
            lock_file = open(lock_file_path, 'w')
            # Try to acquire exclusive lock (non-blocking)
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            print(f"âœ… Lock acquired by worker (PID: {os.getpid()})")
            return lock_file
        except IOError:
            # Lock is held by another process
            if lock_file:
                lock_file.close()
            print(f"â³ Waiting for lock... (PID: {os.getpid()})")
            time.sleep(2)  # Wait before retrying
    
    print(f"âŒ Timeout waiting for lock (PID: {os.getpid()})")
    return None

def release_lock(lock_file):
    """Release the file lock."""
    if lock_file:
        try:
            fcntl.flock(lock_file.fileno(), fcntl.LOCK_UN)
            lock_file.close()
            print(f"ðŸ”“ Lock released by worker (PID: {os.getpid()})")
        except Exception as e:
            print(f"Error releasing lock: {e}")

def check_models_completely_downloaded():
    """
    Check if all required model files are completely downloaded.
    Returns True if all files exist and are valid.
    """
    required_files = [
        "/tmp/ssd_512_resnet101_v2_voc-2cc0f93e.params",
        "/tmp/ssd_512_resnet101_resume_train_four_classes_custom-epoch-26.params",
        "/tmp/detection_model/efficientdet.onnx",
        "/tmp/efficientdet_conf.yml",
        "/tmp/en_core_web_sm-3.8.0/en_core_web_sm/en_core_web_sm-3.8.0/"
        # Add other required model files here
    ]
    
    for file_path in required_files:
        if not os.path.exists(file_path):
            return False
        # Check if file has non-zero size (not corrupted/incomplete)
        if os.path.isfile(file_path) and os.path.getsize(file_path) == 0:
            return False
    
    return True

def download_models_with_lock(SA_keepie_key):
    """
    Download models with file locking to ensure only one worker downloads.
    """
    lock_file_path = "/tmp/model_download.lock"
    download_complete_marker = "/tmp/model_download.complete"
    lock_file = None
    
    try:
        # First, check if models are already completely downloaded
        if check_models_completely_downloaded():
            print(f"âœ… Models already downloaded (PID: {os.getpid()})")
            return True
        
        # Check if download is in progress or completed by another worker
        if os.path.exists(download_complete_marker):
            # Wait a bit for ongoing download to complete
            max_wait = 60
            wait_time = 0
            while wait_time < max_wait:
                if check_models_completely_downloaded():
                    print(f"âœ… Models downloaded by another worker (PID: {os.getpid()})")
                    return True
                time.sleep(5)
                wait_time += 5
        
        # Acquire lock to download
        lock_file = acquire_lock(lock_file_path)
        if not lock_file:
            raise Exception("Failed to acquire lock for model download")
        
        # Double-check after acquiring lock (another worker might have completed)
        if check_models_completely_downloaded():
            print(f"âœ… Models already downloaded after acquiring lock (PID: {os.getpid()})")
            return True
        
        # Create marker file to indicate download is in progress
        with open(download_complete_marker, 'w') as f:
            f.write(f"Download started by PID: {os.getpid()}")
        
        # Perform the actual download
        print(f"ðŸ”„ Starting model download (PID: {os.getpid()})...")
        download_models_internal(SA_keepie_key)
        
        # Update marker to indicate completion
        with open(download_complete_marker, 'w') as f:
            f.write(f"Download completed by PID: {os.getpid()}")
        
        print(f"âœ… Model download completed (PID: {os.getpid()})")
        return True
        
    except Exception as e:
        print(f"âŒ Error in download_models_with_lock: {e}")
        # Clean up marker file on error
        if os.path.exists(download_complete_marker):
            os.remove(download_complete_marker)
        raise
    finally:
        # Always release the lock
        if lock_file:
            release_lock(lock_file)

def download_models_internal(SA_keepie_key):
    """
    Internal function to perform the actual model download.
    This is the original download_models function logic.
    """
    url1 = f"https://{NEXUS_USERNAME}:{get_global_data(SA_keepie_key)}@nexus305.systems.uk.hsbc:8081/nexus/repository/maven-hsbc-gbm/com/hsbc/gbm/dcrest/992994/{NEXUS_DIR}/1.1/{NEXUS_DIR}-1.1.zip"
    print(f"url1: {url1}")

    try:
        # Perform the GET request
        print("ðŸ”„ Downloading the Model...")
        response = requests.get(url1, stream=True, verify=False)
        print("HTTP Status Code", response.status_code)

        # Check if the request was successful
        if response.status_code == 200:
            # Save the file locally
            temp_zip_path = "/tmp/models.zip"
            with open(temp_zip_path, "wb") as file:
                for chunk in response.iter_content(chunk_size=8192):
                    file.write(chunk)

            # Unpack the archive
            shutil.unpack_archive(temp_zip_path, "/tmp")
            print("âœ… Download and extraction complete.")

            # Remove the temporary zip file
            if os.path.isfile("/tmp/models.zip"):
                os.remove("/tmp/models.zip")
                print("ðŸ—‘ï¸ Removed the Downloaded ZIP")
        else:
            print(f"Failed to download file. HTTP Status Code: {response.status_code}")
            raise Exception(f"Download failed with status code: {response.status_code}")

    except requests.exceptions.RequestException as e:
        print(f"An error occurred during the HTTP request: {e}")
        raise
    except shutil.ReadError as e:
        print(f"An error occurred while unpacking the archive: {e}")
        raise
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        raise
    finally:
        if os.path.isfile("/tmp/models.zip"):
            os.remove("/tmp/models.zip")
            print("ðŸ—‘ï¸ Removed the Downloaded ZIP")

# Wrapper function to maintain backward compatibility
def download_models(SA_keepie_key):
    """
    Main entry point for downloading models.
    Uses file locking to ensure only one worker downloads.
    """
    return download_models_with_lock(SA_keepie_key)
