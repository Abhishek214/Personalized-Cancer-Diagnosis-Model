# Quick ONNX Model Test Script - Test your converted model on a single image
# File: test_onnx_single_image.py

import torch
import numpy as np
import yaml
import argparse
import os
import onnxruntime as ort
import cv2
import time

from utils.utils import preprocess

class Params:
    def __init__(self, project_file):
        self.params = yaml.safe_load(open(project_file).read())
    def __getattr__(self, item):
        return self.params.get(item, None)

def test_single_image(onnx_path, image_path, project_file, compound_coef=2, score_threshold=0.001):
    """Test ONNX model on a single image"""
    
    print(f"=== Testing ONNX Model on Single Image ===")
    print(f"Model: {onnx_path}")
    print(f"Image: {image_path}")
    print(f"Score threshold: {score_threshold}")
    
    # Load parameters
    params = Params(project_file)
    input_sizes = [512, 640, 768, 896, 1024, 1280, 1280, 1536, 1536]
    input_size = input_sizes[compound_coef]
    
    # Load ONNX model
    print("Loading ONNX model...")
    try:
        session = ort.InferenceSession(onnx_path, providers=['CPUExecutionProvider'])
        input_name = session.get_inputs()[0].name
        output_names = [out.name for out in session.get_outputs()]
        print(f"‚úì Model loaded successfully")
        print(f"  Input: {input_name}")
        print(f"  Outputs: {output_names}")
    except Exception as e:
        print(f"‚ùå Failed to load ONNX model: {e}")
        return False
    
    # Load and preprocess image
    print("Preprocessing image...")
    try:
        if not os.path.exists(image_path):
            print(f"‚ùå Image not found: {image_path}")
            return False
        
        # Read original image for display
        original_img = cv2.imread(image_path)
        if original_img is None:
            print(f"‚ùå Could not read image: {image_path}")
            return False
        
        print(f"  Original image shape: {original_img.shape}")
        
        # Preprocess using same method as evaluation
        ori_imgs, framed_imgs, framed_metas = preprocess(
            [image_path],
            max_size=input_size,
            mean=params.mean,
            std=params.std
        )
        
        # Prepare input tensor
        x = framed_imgs[0]
        x = np.expand_dims(x, axis=0)  # Add batch dimension
        x = np.transpose(x, (0, 3, 1, 2))  # Convert to NCHW
        
        print(f"  Preprocessed shape: {x.shape}")
        print(f"  Input range: [{x.min():.3f}, {x.max():.3f}]")
        
    except Exception as e:
        print(f"‚ùå Preprocessing failed: {e}")
        return False
    
    # Run inference
    print("Running inference...")
    try:
        start_time = time.time()
        outputs = session.run(None, {input_name: x})
        inference_time = time.time() - start_time
        
        boxes, scores, classes = outputs
        print(f"‚úì Inference successful in {inference_time*1000:.1f} ms")
        print(f"  Output shapes: boxes={boxes.shape}, scores={scores.shape}, classes={classes.shape}")
        
    except Exception as e:
        print(f"‚ùå Inference failed: {e}")
        return False
    
    # Analyze outputs
    print("Analyzing outputs...")
    
    # Get detections for first (and only) image
    img_boxes = boxes[0]
    img_scores = scores[0]
    img_classes = classes[0]
    
    print(f"  Raw output ranges:")
    print(f"    Boxes: [{img_boxes.min():.3f}, {img_boxes.max():.3f}]")
    print(f"    Scores: [{img_scores.min():.3f}, {img_scores.max():.3f}]")
    print(f"    Classes: [{img_classes.min():.0f}, {img_classes.max():.0f}]")
    
    # Filter by score threshold
    valid_mask = img_scores > score_threshold
    valid_count = np.sum(valid_mask)
    
    print(f"  Valid detections (score > {score_threshold}): {valid_count}")
    
    if valid_count == 0:
        print("‚ö† No detections above threshold. Try lowering score_threshold.")
        # Show score distribution
        sorted_scores = np.sort(img_scores[img_scores > 0])[::-1]  # Descending order
        if len(sorted_scores) > 0:
            print(f"  Top scores: {sorted_scores[:10]}")
        return True
    
    # Get valid detections
    valid_boxes = img_boxes[valid_mask]
    valid_scores = img_scores[valid_mask]
    valid_classes = img_classes[valid_mask]
    
    # Sort by score
    sort_indices = np.argsort(valid_scores)[::-1]
    valid_boxes = valid_boxes[sort_indices]
    valid_scores = valid_scores[sort_indices]
    valid_classes = valid_classes[sort_indices]
    
    print(f"  Top detections:")
    for i in range(min(5, len(valid_scores))):
        score = valid_scores[i]
        class_id = int(valid_classes[i])
        box = valid_boxes[i]
        print(f"    Detection {i+1}: class={class_id}, score={score:.4f}, box=[{box[0]:.1f}, {box[1]:.1f}, {box[2]:.1f}, {box[3]:.1f}]")
    
    # Test different confidence thresholds
    print(f"  Detection counts at different confidence thresholds:")
    for conf_thresh in [0.001, 0.01, 0.05, 0.1, 0.3, 0.5]:
        count = np.sum(valid_scores >= conf_thresh)
        print(f"    >= {conf_thresh}: {count} detections")
    
    print(f"‚úÖ Single image test completed successfully!")
    print(f"üí° Suggested confidence threshold for evaluation: {suggest_confidence_threshold(valid_scores):.3f}")
    
    return True

def suggest_confidence_threshold(scores):
    """Suggest a good confidence threshold based on score distribution"""
    if len(scores) == 0:
        return 0.05
    
    # Use 75th percentile as a reasonable threshold
    return float(np.percentile(scores, 75))

def main():
    parser = argparse.ArgumentParser('Test ONNX Model on Single Image')
    parser.add_argument('-m', '--model', type=str, required=True, help='Path to ONNX model')
    parser.add_argument('-i', '--image', type=str, required=True, help='Path to test image')
    parser.add_argument('-p', '--project', type=str, default='projects/abhil.yml', help='Project file')
    parser.add_argument('-c', '--compound_coef', type=int, default=2, help='Compound coefficient')
    parser.add_argument('--score_threshold', type=float, default=0.001, help='Score threshold')
    
    args = parser.parse_args()
    
    # Validate inputs
    if not os.path.exists(args.model):
        print(f"‚ùå ONNX model not found: {args.model}")
        exit(1)
    
    if not os.path.exists(args.image):
        print(f"‚ùå Test image not found: {args.image}")
        exit(1)
    
    if not os.path.exists(args.project):
        print(f"‚ùå Project file not found: {args.project}")
        exit(1)
    
    # Run test
    success = test_single_image(
        args.model, args.image, args.project, 
        args.compound_coef, args.score_threshold
    )
    
    if success:
        print(f"\n‚úÖ Your ONNX model is working correctly!")
        print(f"üöÄ Ready for full evaluation with:")
        print(f"   python evaluate_onnx_model.py -p abhil -c {args.compound_coef} -w {args.model}")
    else:
        print(f"\n‚ùå Issues detected with your ONNX model")

if __name__ == '__main__':
    main()
