import json
import os
import argparse
import numpy as np
import yaml
from tqdm import tqdm
import onnxruntime as ort

from pycocotools.coco import COCO
from pycocotools.cocoeval import COCOeval
from utils.utils import preprocess, invert_affine, boolean_string

class ONNXEfficientDetFixed:
    def __init__(self, model_path, device='cpu'):
        self.device = device
        providers = ['CUDAExecutionProvider', 'CPUExecutionProvider'] if device == 'cuda' else ['CPUExecutionProvider']
        self.session = ort.InferenceSession(model_path, providers=providers)
        
        self.input_name = self.session.get_inputs()[0].name
        self.output_names = [output.name for output in self.session.get_outputs()]
    
    def predict(self, image_tensor):
        if hasattr(image_tensor, 'numpy'):
            image_np = image_tensor.numpy()
        else:
            image_np = image_tensor
            
        outputs = self.session.run(self.output_names, {self.input_name: image_np})
        return outputs[0], outputs[1], outputs[2]  # boxes, scores, classes

def evaluate_onnx_coco_fixed(img_path, set_name, image_ids, coco, model, compound_coef, params):
    results = []
    input_sizes = [512, 640, 768, 896, 1024, 1280, 1280, 1536, 1536]
    
    for image_id in tqdm(image_ids):
        image_info = coco.loadImgs(image_id)[0]
        image_path = img_path + image_info['file_name']

        # CRITICAL FIX 7: Use exact same preprocessing as original
        ori_imgs, framed_imgs, framed_metas = preprocess(
            [image_path],  # Note: preprocess expects list
            max_size=input_sizes[compound_coef],
            mean=params['mean'],
            std=params['std']
        )

        # Prepare input for ONNX
        x = framed_imgs[0]
        x = np.expand_dims(x, axis=0)
        x = np.transpose(x, (0, 3, 1, 2))

        # Run ONNX inference
        boxes, scores, classes = model.predict(x)
        
        # Remove batch dimension and padding
        boxes = boxes[0]  # Remove batch dim
        scores = scores[0] 
        classes = classes[0]
        
        # Remove padded detections (score = 0)
        valid_mask = scores > 0
        if not valid_mask.any():
            continue
            
        final_boxes = boxes[valid_mask]
        final_scores = scores[valid_mask]
        final_classes = classes[valid_mask]

        # CRITICAL FIX 8: Proper coordinate transformation
        try:
            # Create predictions in exact same format as original
            preds = [{
                'rois': final_boxes,
                'scores': final_scores,
                'class_ids': final_classes
            }]
            
            # Use the same invert_affine function
            preds = invert_affine(framed_metas, preds)[0]
            
            final_boxes = preds['rois']
            final_scores = preds['scores']
            final_classes = preds['class_ids']
            
        except Exception as e:
            print(f"Coordinate transformation failed for image {image_id}: {e}")
            continue

        # Process results in COCO format
        for i in range(len(final_boxes)):
            box = final_boxes[i]
            score = float(final_scores[i])
            class_id = int(final_classes[i])
            
            # Convert [x1,y1,x2,y2] to [x,y,w,h] for COCO format
            x1, y1, x2, y2 = box
            width = x2 - x1
            height = y2 - y1
            
            if width <= 0 or height <= 0:
                continue
                
            image_result = {
                'image_id': image_id,
                'category_id': class_id + 1,  # COCO categories start from 1
                'score': score,
                'bbox': [float(x1), float(y1), float(width), float(height)],
            }
            results.append(image_result)

    if not len(results):
        raise Exception("No valid detections found")

    # Write output
    filepath = f'{set_name}_bbox_results_onnx_fixed.json'
    if os.path.exists(filepath):
        os.remove(filepath)
    json.dump(results, open(filepath, 'w'), indent=4)
    return filepath

# Rest of evaluation code remains the same...
