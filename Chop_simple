import cv2
import numpy as np
import random
import os
from PIL import Image
from pathlib import Path
import albumentations as A

def apply_chop_transformations(chop_image):
    """Apply realistic transformations to chop images"""
    transform = A.Compose([
        A.Rotate(limit=360, p=0.8, border_mode=cv2.BORDER_CONSTANT, value=255),
        A.RandomScale(scale_limit=0.3, p=0.7),
        A.GaussianBlur(blur_limit=(1, 3), p=0.3),
        A.RandomBrightnessContrast(brightness_limit=0.2, contrast_limit=0.2, p=0.5),
        A.GaussNoise(var_limit=(10, 50), p=0.2),
    ])
    return transform(image=chop_image)['image']

def make_chop_transparent(chop_image):
    """Make chop background transparent"""
    if chop_image.shape[2] == 3:
        chop_image = cv2.cvtColor(chop_image, cv2.COLOR_BGR2BGRA)
    
    gray = cv2.cvtColor(chop_image[:,:,:3], cv2.COLOR_BGR2GRAY)
    _, mask = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY)
    chop_image[:,:,3] = 255 - mask
    
    alpha_factor = random.uniform(0.7, 0.95)
    chop_image[:,:,3] = (chop_image[:,:,3] * alpha_factor).astype(np.uint8)
    
    return chop_image

def find_safe_areas(document):
    """Find areas where chops can be placed"""
    height, width = document.shape[:2]
    gray = cv2.cvtColor(document, cv2.COLOR_BGR2GRAY)
    
    edges = cv2.Canny(gray, 50, 150)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    dilated = cv2.dilate(edges, kernel, iterations=2)
    
    contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    occupied_mask = np.zeros_like(gray)
    for contour in contours:
        cv2.fillPoly(occupied_mask, [contour], 255)
    
    free_mask = cv2.bitwise_not(occupied_mask)
    
    margin = 50
    safe_areas = []
    grid_size = 100
    
    for y in range(margin, height - margin, grid_size):
        for x in range(margin, width - margin, grid_size):
            roi = free_mask[y:y+grid_size, x:x+grid_size]
            if np.sum(roi) > (grid_size * grid_size * 0.7):
                safe_areas.append((x, y, x+grid_size, y+grid_size))
    
    return safe_areas

def place_chop_on_document(document, chop, position, scale_factor=1.0):
    """Place chop on document"""
    # Resize chop
    chop_height, chop_width = chop.shape[:2]
    new_height = int(chop_height * scale_factor)
    new_width = int(chop_width * scale_factor)
    chop_resized = cv2.resize(chop, (new_width, new_height))
    
    # Apply transformations
    chop_transformed = apply_chop_transformations(chop_resized)
    chop_with_alpha = make_chop_transparent(chop_transformed)
    
    # Get placement coordinates
    x, y = position
    doc_height, doc_width = document.shape[:2]
    
    x = max(0, min(x, doc_width - new_width))
    y = max(0, min(y, doc_height - new_height))
    
    # Convert document to RGBA
    if document.shape[2] == 3:
        document_rgba = cv2.cvtColor(document, cv2.COLOR_BGR2BGRA)
    else:
        document_rgba = document.copy()
    
    # Blend chop with document
    roi = document_rgba[y:y+new_height, x:x+new_width]
    alpha = chop_with_alpha[:,:,3:4] / 255.0
    chop_rgb = chop_with_alpha[:,:,:3]
    
    min_h = min(roi.shape[0], chop_rgb.shape[0], alpha.shape[0])
    min_w = min(roi.shape[1], chop_rgb.shape[1], alpha.shape[1])
    
    blended = roi[:min_h, :min_w, :3] * (1 - alpha[:min_h, :min_w]) + chop_rgb[:min_h, :min_w] * alpha[:min_h, :min_w]
    document_rgba[y:y+min_h, x:x+min_w, :3] = blended.astype(np.uint8)
    
    return cv2.cvtColor(document_rgba, cv2.COLOR_BGRA2BGR)

def augment_images(chop_images_dir, document_images_dir, output_dir, num_chops_per_doc=3):
    """Main function to augment images"""
    chop_dir = Path(chop_images_dir)
    doc_dir = Path(document_images_dir)
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True)
    
    # Load image paths
    chop_images = list(chop_dir.glob("*.jpg")) + list(chop_dir.glob("*.png"))
    doc_images = list(doc_dir.glob("*.jpg")) + list(doc_dir.glob("*.png"))
    
    for doc_path in doc_images:
        document = cv2.imread(str(doc_path))
        if document is None:
            continue
        
        safe_areas = find_safe_areas(document)
        num_chops = min(num_chops_per_doc, len(safe_areas))
        
        if num_chops == 0:
            continue
        
        selected_areas = random.sample(safe_areas, num_chops)
        result_document = document.copy()
        
        for i in range(num_chops):
            chop_path = random.choice(chop_images)
            chop = cv2.imread(str(chop_path))
            
            if chop is None:
                continue
            
            scale_factor = random.uniform(0.3, 1.2)
            x1, y1, x2, y2 = selected_areas[i]
            pos_x = random.randint(x1, max(x1, x2 - int(chop.shape[1] * scale_factor)))
            pos_y = random.randint(y1, max(y1, y2 - int(chop.shape[0] * scale_factor)))
            
            result_document = place_chop_on_document(
                result_document, chop, (pos_x, pos_y), scale_factor
            )
        
        # Save result
        output_name = f"{doc_path.stem}_with_chops_{random.randint(1000, 9999)}.jpg"
        output_file = output_path / output_name
        cv2.imwrite(str(output_file), result_document)
        print(f"Saved: {output_file}")

# Usage
if __name__ == "__main__":
    augment_images(
        chop_images_dir="./chop_images",
        document_images_dir="./document_images", 
        output_dir="./output_images",
        num_chops_per_doc=3
    )
